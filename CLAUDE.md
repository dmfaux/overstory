# Overstory

Project-agnostic swarm system for Claude Code agent orchestration. Overstory turns a single Claude Code session into a multi-agent team by spawning worker agents in git worktrees via tmux, coordinating them through a custom SQLite mail system, and merging their work back with tiered conflict resolution.

**Your Claude Code session IS the orchestrator.** There is no separate daemon. CLAUDE.md + hooks + the `overstory` CLI provide everything.

## Tech Stack

- **Runtime:** Bun (runs TypeScript directly, no build step)
- **Language:** TypeScript with strict mode (`noUncheckedIndexedAccess`, no `any`)
- **Linting:** Biome (formatter + linter in one tool)
- **Runtime dependencies:** Zero. Only Bun built-in APIs (`bun:sqlite`, `Bun.spawn`, `Bun.file`, etc.)
- **Dev dependencies:** `@types/bun`, `typescript`, `@biomejs/biome`
- **External CLIs (not npm deps):** `bd` (beads) for issue tracking, `mulch` for expertise, `git`, `tmux`

## Architecture

### Orchestrator Model

When you open Claude Code in a project with `.overstory/` initialized:
1. `SessionStart` hook runs `overstory prime` (loads config, recent activity, mulch expertise)
2. `UserPromptSubmit` hook runs `overstory mail check --inject` (surfaces new messages from agents)
3. You use the `overstory` CLI via Bash tool to spawn agents, check status, merge work

### Agent Definitions: Library Base + Dynamic Overlay

Each agent gets two instruction layers:

- **Layer 1 (Base):** Reusable `.md` files in `agents/` defining the HOW (workflow, constraints, capabilities)
- **Layer 2 (Overlay):** Per-task `CLAUDE.md` generated by `overstory sling`, written to worktree, defining the WHAT (task ID, file scope, spec path, branch name)

The orchestrator (or a team lead) only passes WHAT. The base definition already has HOW.

### Hierarchical Delegation

```
Orchestrator (your Claude Code session)
  --> Team Lead (Claude Code in tmux, can spawn sub-workers)
        --> Specialist Workers (Claude Code in tmux, leaf nodes)
```

Depth limit is configurable (default 2). Prevents runaway spawning.

### Messaging: Custom SQLite Mail

Purpose-built messaging via `bun:sqlite` in `.overstory/mail.db`. WAL mode for concurrent access from multiple agents. ~1-5ms per query. Independent of beads (which is too slow for high-frequency polling).

## Directory Structure

```
overstory/                        # This repo (the overstory tool itself)
  src/
    index.ts                      # CLI entry point (command router)
    types.ts                      # ALL shared types and interfaces
    config.ts                     # Config loader + defaults + validation
    errors.ts                     # Custom error types (extend OverstoryError)
    commands/                     # One file per CLI subcommand
      init.ts                     # overstory init
      sling.ts                    # overstory sling (spawn worker)
      status.ts                   # overstory status
      prime.ts                    # overstory prime
      mail.ts                     # overstory mail send/check/list/read/reply
      merge.ts                    # overstory merge
      worktree.ts                 # overstory worktree list/clean
      log.ts                      # overstory log (hook target)
      watch.ts                    # overstory watch (watchdog)
      metrics.ts                  # overstory metrics
    agents/                       # Agent lifecycle management
      manifest.ts                 # Agent registry (load + query capabilities)
      overlay.ts                  # Dynamic CLAUDE.md overlay generator
      identity.ts                 # Persistent agent identity (CVs)
      hooks-deployer.ts           # Deploy hooks config to worktree
    worktree/
      manager.ts                  # Create/list/cleanup git worktrees via Bun.spawn
      tmux.ts                     # Tmux session management via Bun.spawn
    beads/
      client.ts                   # bd CLI wrapper (--json parsing)
      molecules.ts                # Molecule management helpers
    mail/
      store.ts                    # SQLite mail storage (bun:sqlite, WAL mode)
      client.ts                   # Mail operations (send/check/list/read/reply)
    mulch/
      client.ts                   # mulch CLI wrapper
    merge/
      queue.ts                    # FIFO merge queue
      resolver.ts                 # Tiered conflict resolution (4 tiers)
    watchdog/
      daemon.ts                   # Tier 1: mechanical process monitoring
      triage.ts                   # Tier 2: AI-assisted failure classification
      health.ts                   # Health check definitions + state machine
    logging/
      logger.ts                   # Multi-format logger (human + NDJSON)
      sanitizer.ts                # Secret redaction
      reporter.ts                 # Console reporter (ANSI colors)
    metrics/
      store.ts                    # SQLite metrics storage
      summary.ts                  # Metrics reporting
  agents/                         # Base agent definitions (the HOW)
    scout.md                      # Read-only exploration
    builder.md                    # Implementation
    reviewer.md                   # Read-only validation
    lead.md                       # Team lead (can spawn sub-workers)
    merger.md                     # Branch merge specialist
  templates/
    CLAUDE.md.tmpl                # Template for orchestrator CLAUDE.md
    overlay.md.tmpl               # Template for per-worker overlay
    hooks.json.tmpl               # Template for settings.local.json
  __tests__/                      # All tests live here
```

### What `overstory init` creates in a target project

```
target-project/
  .overstory/
    config.yaml                   # Project configuration
    agent-manifest.json           # Agent registry
    hooks.json                    # Central hooks config
    agents/{name}/                # Agent state + identity
    worktrees/{agent-name}/       # Git worktrees (gitignored)
    specs/{bead-id}.md            # Task specifications
    logs/{agent-name}/{ts}/       # Agent logs (gitignored)
    mail.db                       # SQLite mail (gitignored, WAL mode)
    metrics.db                    # SQLite metrics (gitignored)
```

## Coding Conventions

### Formatting

- **Tab indentation** (enforced by Biome)
- **100 character line width** (enforced by Biome)
- Biome handles import organization automatically

### TypeScript

- Strict mode with `noUncheckedIndexedAccess` -- always handle possible `undefined` from indexing
- `noExplicitAny` is an error -- use `unknown` and narrow, or define proper types
- `useConst` is enforced -- use `const` unless reassignment is needed
- `noNonNullAssertion` is a warning -- avoid `!` postfix, check for null/undefined instead
- All shared types and interfaces go in `src/types.ts`
- All error types go in `src/errors.ts` and must extend `OverstoryError` base class

### Dependencies

- **Zero runtime dependencies.** This is a hard rule.
- Use only Bun built-in APIs: `bun:sqlite` for databases, `Bun.spawn` for subprocesses, `Bun.file` for file I/O, `Bun.write` for writes
- External tools (`bd`, `mulch`, `git`, `tmux`) are invoked as subprocesses via `Bun.spawn`, never as npm imports
- Dev dependencies are limited to types and tooling

### File Organization

- Each CLI command gets its own file in `src/commands/`
- Each subsystem gets its own directory under `src/` (agents, worktree, beads, mail, etc.)
- Base agent definitions (`.md` files) live in `agents/` at the repo root
- Templates live in `templates/` at the repo root
- Tests live in `__tests__/` at the repo root

### Subprocess Execution

All external commands run through `Bun.spawn`. Capture stdout/stderr, check exit codes, throw typed errors on failure.

```typescript
const proc = Bun.spawn(["git", "worktree", "add", path, "-b", branch], {
  cwd: repoRoot,
  stdout: "pipe",
  stderr: "pipe",
});
const exitCode = await proc.exited;
if (exitCode !== 0) {
  const stderr = await new Response(proc.stderr).text();
  throw new WorktreeError(`Failed to create worktree: ${stderr}`);
}
```

### SQLite

All SQLite uses `bun:sqlite` (synchronous API). Always enable WAL mode and busy timeout for concurrent access:

```typescript
import { Database } from "bun:sqlite";
const db = new Database(dbPath);
db.exec("PRAGMA journal_mode=WAL");
db.exec("PRAGMA busy_timeout=5000");
```

## CLI Command Reference

```
overstory init                          Initialize .overstory/ in current project

overstory sling <task-id>              Spawn a worker agent
  --capability <type>                    builder | scout | reviewer | lead | merger
  --name <name>                          Unique agent name
  --spec <path>                          Path to task spec file
  --files <f1,f2,...>                    Exclusive file scope
  --parent <agent-name>                  Parent (for hierarchy tracking)
  --depth <n>                            Current hierarchy depth

overstory prime                         Load context for orchestrator/agent
  --agent <name>                         Per-agent priming
  --compact                              Less context (for PreCompact hook)

overstory status                        Show all active agents, worktrees, beads state
  --json                                 JSON output
  --watch                                Live updating

overstory mail send                     Send a message
  --to <agent>  --subject <text>  --body <text>
  --type <status|question|result|error>
  --priority <low|normal|high|urgent>

overstory mail check                    Check inbox (unread messages)
  --agent <name>  --inject  --json

overstory mail list                     List messages with filters
  --from <name>  --to <name>  --unread

overstory mail read <id>                Mark message as read
overstory mail reply <id> --body <text> Reply in same thread

overstory merge                         Merge agent branches into canonical
  --branch <name>                        Specific branch
  --all                                  All completed branches
  --dry-run                              Check for conflicts only

overstory worktree list                 List worktrees with status
overstory worktree clean                Remove completed worktrees
  --completed                            Only finished agents
  --all                                  Force remove all

overstory log <event>                   Log an event (called by hooks)
  --agent <name>
  Events: tool-start, tool-end, session-end

overstory watch                         Start watchdog daemon
  --interval <ms>  --background

overstory metrics                       Show session metrics
  --last <n>  --json
```

## Testing

- **Framework:** `bun test` (built-in, Jest-compatible API)
- **Test location:** All tests in `__tests__/` directory at repo root
- **Naming:** `{module}.test.ts` (e.g., `config.test.ts`, `mail-store.test.ts`)
- **Run tests:** `bun test`
- **Run single test:** `bun test __tests__/config.test.ts`

Tests should mock subprocess calls (`Bun.spawn`) rather than requiring real `git`, `tmux`, `bd`, or `mulch` binaries. Use temp directories for filesystem tests. SQLite tests use in-memory databases or temp files.

## Tool Integration

### beads (bd) -- Issue Tracking

```bash
bd ready                              # Find available work
bd show <id>                          # View issue details
bd update <id> --status in_progress   # Claim work
bd close <id> --reason "summary"      # Complete work
bd sync                               # Sync with git
```

Issues are tracked in `.beads/issues.jsonl`. Beads owns all task lifecycle (create, assign, close, dependencies, molecules). Overstory wraps `bd` via `src/beads/client.ts`.

### mulch -- Structured Expertise

```bash
mulch prime [domain]                  # Output priming prompt
mulch status                          # Show domain statistics
mulch record <domain>                 # Record expertise
mulch search [query]                  # Search across domains
```

Expertise records live in `.mulch/`. Overstory wraps `mulch` via `src/mulch/client.ts`.

## Quality Gates

Run all three before committing:

```bash
bun test                              # Tests pass
biome check .                         # Linting + formatting clean
tsc --noEmit                          # Type checking passes
```

Or use the package.json scripts:

```bash
bun run test                          # bun test
bun run lint                          # biome check .
bun run typecheck                     # tsc --noEmit
```

## Session Completion Protocol

When ending a work session, you MUST:

1. File issues for remaining work (`bd create`)
2. Run quality gates (if code changed): `bun test && biome check . && tsc --noEmit`
3. Update issue status: close finished work, update in-progress items
4. Push to remote (MANDATORY):
   ```bash
   git pull --rebase
   bd sync
   git push
   git status  # MUST show "up to date with origin"
   ```
5. Verify all changes are committed AND pushed
6. Hand off context for the next session

Work is NOT complete until `git push` succeeds.
