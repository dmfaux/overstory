# Overstory Implementation Plan

> From conceptual blueprint to buildable TypeScript system.
> Generated 2026-02-12. Revised after alignment sessions covering orchestrator model,
> messaging, hierarchy, Gas Town patterns, and kotadb issue #200.

---

## Decisions (Locked)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Repo | `~/Projects/overstory` (new standalone) | Project-agnostic swarm system |
| Runtime | Bun | Match kotadb patterns, fast startup, native APIs |
| Language | TypeScript (strict) | `noUncheckedIndexedAccess`, no `any` |
| Linting | Biome | Fast, Bun-friendly, single tool |
| Task mgmt | beads (`bd` CLI, v0.49.6) | Hash IDs, dependency graphs, molecules |
| Expertise | mulch (`mulch` CLI + npm types, v0.2.3) | JSONL-based, git-native, auto-expire |
| Orchestrator | User's Claude Code session | CLAUDE.md + hooks + `overstory` CLI via Bash |
| Worker sessions | Claude Code in tmux | Supports messaging, inspection, multi-step |
| Agent definitions | Library base + dynamic overlay | Base `.md` = HOW, overlay CLAUDE.md = WHAT |
| Hierarchy | Hierarchical delegation | Orchestrator -> team leads -> specialists |
| Messaging | Custom SQLite mail | Purpose-built, ~1-5ms queries, independent of beads |
| Result reporting | Beads only | `bd close` with result summary |
| State location | In target repo (`.overstory/`) | Gitignored, shared filesystem |
| Capabilities | Dynamic, not fixed roles | Agents get tool sets assigned per-task |
| Scope | Full Phase 1-3 (up to 15 agents) | All components including watchdog |

---

## How It Works (End-to-End)

```
Human opens Claude Code in project root
  │
  │  CLAUDE.md references overstory conventions
  │  SessionStart hook runs: overstory prime
  │
  ▼
Human: "Build auth module — needs login, signup, and password reset"
  │
  ▼
Orchestrator (Claude Code) thinks:
  1. This needs 3 parallel workers + 1 merge coordinator
  2. Each worker gets exclusive file ownership
  3. Uses hierarchical delegation: spawn a build-team-lead
  │
  ├── overstory sling --task bd-abc --capability builder --name auth-login
  │     → Creates worktree, writes overlay CLAUDE.md, starts tmux session
  │     → Worker reads base agent def + overlay, executes task
  │     → Worker calls: bd close bd-abc --reason "login implemented"
  │     → Worker exits, tmux session closes
  │
  ├── overstory sling --task bd-def --capability builder --name auth-signup
  │     → Same pattern, different worktree + branch
  │
  └── overstory sling --task bd-ghi --capability builder --name auth-reset
        → Same pattern
  │
  ▼
Orchestrator polls: overstory status
  → Sees 3 agents working, tracks via beads
  │
  ▼
As agents complete (bd close):
  overstory merge --branch agent-auth-login/bd-abc
  overstory merge --branch agent-auth-signup/bd-def
  overstory merge --branch agent-auth-reset/bd-ghi
  │
  ▼
Orchestrator: "All 3 merged. Auth module complete."
```

---

## The Orchestrator Model

**Your Claude Code session IS the orchestrator.** There is no separate Mayor process.

When you open Claude Code in a project with `.overstory/` initialized:
- CLAUDE.md tells Claude about overstory conventions and available CLI commands
- SessionStart hook runs `overstory prime` (loads config, recent activity, mulch)
- UserPromptSubmit hook runs `overstory mail check --inject` (surfaces new messages)
- Claude uses `overstory` CLI via Bash tool to manage everything

**Why this works:**
- No extra infrastructure (tmux wrapper, daemon, separate session)
- You already have a conversational interface (Claude Code)
- The `overstory` CLI handles all stateful operations
- Claude Code's hooks provide the integration points

---

## Agent Definition Model

### Library Base + Dynamic Overlay

Each agent gets two layers of instructions:

**Layer 1: Base definition** (reusable, lives in `agents/` directory)
```markdown
# agents/builder.md
You are a builder agent. Your job is to implement changes according to a spec.

## Capabilities
- Read, Write, Edit files
- Run bash commands (git, tests, lint)
- Send mail via `overstory mail send`

## Workflow
1. Read your task spec at the path provided in CLAUDE.md
2. Read relevant expertise via `mulch prime`
3. Implement the changes
4. Run quality gates: `bun test`, `biome check`
5. Report completion: `bd close <task-id> --reason "summary"`

## Constraints
- Only modify files listed in your FILE_SCOPE
- Never push directly to the canonical branch
- Commit to your worktree branch only
```

**Layer 2: Dynamic overlay** (generated per-task, written to worktree)
```markdown
# .claude/CLAUDE.md (generated by overstory sling)
# Auto-generated by overstory. Do not edit.

## Your Assignment
- **Task ID:** bd-abc123
- **Agent Name:** auth-login
- **Spec:** .overstory/specs/bd-abc123.md
- **Branch:** agent-auth-login/bd-abc123

## File Scope (exclusive ownership)
- src/auth/login.ts
- src/auth/login.test.ts
- src/auth/types.ts

## Expertise
Run: `mulch prime auth api --format json`

## Communication
- Send mail: `overstory mail send --to orchestrator --subject "done" --body "..."`
- Check mail: `overstory mail check`
- Your address: agent-auth-login
```

**Key insight from kotadb #200:** The base definition IS the system prompt. The team lead (or orchestrator) only needs to pass WHAT (the overlay), not HOW (already in the base). This keeps delegation minimal.

### Hierarchical Delegation

Agents above craft the system prompts for agents below:

```
Orchestrator (your Claude Code session)
  │
  │  Decides: "This needs a build team lead"
  │  Calls: overstory sling --task bd-xyz --capability lead --name build-lead
  │
  └── Build Team Lead (Claude Code in tmux)
        │  Reads: agents/lead.md (base) + overlay (task context)
        │  Decides: "I need 3 specialist builders"
        │
        ├── overstory sling --task bd-abc --capability builder --name auth-login
        ├── overstory sling --task bd-def --capability builder --name auth-signup
        └── overstory sling --task bd-ghi --capability builder --name auth-reset
              │
              Each reads: agents/builder.md (base) + overlay (file scope, spec)
```

**Depth limit:** Configurable, default 2 (orchestrator -> lead -> worker). Prevents runaway spawning.

---

## Messaging: Custom SQLite Mail

Purpose-built messaging system using SQLite (`bun:sqlite`). Independent of beads.

**Why not beads for mail?**
- Mail is high-frequency (agents poll on every prompt via hooks). `bd` CLI spawns at ~50-200ms each — too slow for 10+ agents polling.
- Abstraction mismatch: issues have status/priority/assignee/blocks — messages need from/to/subject/body. Fighting the model, not leveraging it.
- Separation of concerns: beads = task management, mail = communication. Independent failure domains.
- SQLite via `bun:sqlite` = ~1-5ms per query, zero external deps, atomic writes.

**Beads still owns:** task lifecycle (`bd create/ready/close`), molecules, convoy tracking, atomic task claiming.

### Schema

```sql
-- .overstory/mail.db

CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,              -- "msg-" + nanoid(12)
  from_agent TEXT NOT NULL,         -- sender agent name
  to_agent TEXT NOT NULL,           -- recipient agent name or "orchestrator"
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  type TEXT NOT NULL DEFAULT 'status',    -- status | question | result | error
  priority TEXT NOT NULL DEFAULT 'normal', -- low | normal | high | urgent
  thread_id TEXT,                   -- optional: group related messages
  read INTEGER NOT NULL DEFAULT 0,  -- 0 = unread, 1 = read
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_inbox ON messages(to_agent, read);
CREATE INDEX IF NOT EXISTS idx_thread ON messages(thread_id);
```

### Message Format

```typescript
interface MailMessage {
  id: string;                // "msg-a1b2c3d4e5f6"
  from: string;              // "auth-login" (agent name)
  to: string;                // "orchestrator" | "build-lead" | "auth-signup"
  subject: string;
  body: string;
  priority: "low" | "normal" | "high" | "urgent";
  type: "status" | "question" | "result" | "error";
  threadId: string | null;   // For conversation threading
  read: boolean;
  createdAt: string;         // ISO timestamp
}
```

### CLI Commands

```bash
# Send a message (INSERT into SQLite)
overstory mail send --to orchestrator --subject "Build complete" \
  --body "Implemented login flow. Tests passing." --type result

# Check inbox (SELECT unread WHERE to_agent = name)
overstory mail check                    # Human-readable
overstory mail check --json             # JSON output
overstory mail check --inject           # Formatted for hook context injection

# List all mail (with filters)
overstory mail list
overstory mail list --from auth-login   # Filter by sender
overstory mail list --unread            # Unread only

# Mark as read (UPDATE read = 1)
overstory mail read <message-id>

# Reply (creates message with same thread_id)
overstory mail reply <message-id> --body "Acknowledged, proceeding."
```

### Hook Integration

Workers receive messages via the `UserPromptSubmit` hook:

```json
// .claude/settings.local.json (deployed to each worktree)
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "matcher": "",
        "hooks": [{
          "type": "command",
          "command": "overstory mail check --inject --agent $OVERSTORY_AGENT_NAME"
        }]
      }
    ]
  }
}
```

When the agent submits a prompt, the hook queries SQLite for unread messages and injects them into context. ~1-5ms per check — negligible overhead even at scale.

### Concurrency

SQLite WAL mode handles concurrent reads/writes from multiple agent processes:

```typescript
// On DB open
db.exec("PRAGMA journal_mode=WAL");
db.exec("PRAGMA busy_timeout=5000");
```

Multiple agents in separate worktrees can all read/write `.overstory/mail.db` safely — WAL mode allows concurrent readers with one writer, and busy_timeout handles contention.

---

## Hooks & Logging

### Hook Architecture

Central config at `.overstory/hooks.json`, deployed to each worktree as `.claude/settings.local.json`.

```typescript
interface HooksConfig {
  // Runs when agent session starts
  SessionStart: HookEntry[];
  // Runs before each prompt submission
  UserPromptSubmit: HookEntry[];
  // Runs before each tool use (logging)
  PreToolUse: HookEntry[];
  // Runs after each tool use (logging)
  PostToolUse: HookEntry[];
  // Runs when session ends
  Stop: HookEntry[];
  // Runs before context compaction
  PreCompact: HookEntry[];
}

interface HookEntry {
  type: "command";
  command: string;
  matcher?: string;       // Tool name pattern for Pre/PostToolUse
}
```

### Default Hook Set

```json
{
  "hooks": {
    "SessionStart": [{
      "type": "command",
      "command": "overstory prime --agent $OVERSTORY_AGENT_NAME"
    }],
    "UserPromptSubmit": [{
      "matcher": "",
      "hooks": [{
        "type": "command",
        "command": "overstory mail check --inject --agent $OVERSTORY_AGENT_NAME"
      }]
    }],
    "PreToolUse": [{
      "matcher": "",
      "hooks": [{
        "type": "command",
        "command": "overstory log tool-start --agent $OVERSTORY_AGENT_NAME"
      }]
    }],
    "PostToolUse": [{
      "matcher": "",
      "hooks": [{
        "type": "command",
        "command": "overstory log tool-end --agent $OVERSTORY_AGENT_NAME"
      }]
    }],
    "Stop": [{
      "type": "command",
      "command": "overstory log session-end --agent $OVERSTORY_AGENT_NAME"
    }],
    "PreCompact": [{
      "type": "command",
      "command": "overstory prime --agent $OVERSTORY_AGENT_NAME --compact"
    }]
  }
}
```

### Logging System

Multi-format logging, inspired by kotadb:

```
.overstory/logs/{agent-name}/{session-timestamp}/
├── session.log           # Human-readable: [TIMESTAMP] EVENT key=value
├── events.ndjson         # Machine-parseable NDJSON stream
├── tools.ndjson          # Tool use log (from Pre/PostToolUse hooks)
└── errors.log            # Stack traces with context
```

**What gets logged:**
- Agent lifecycle: boot, prime, execute, complete, terminate
- All tool uses: tool name, arguments (sanitized), duration, result summary
- File modifications: path, operation (create/edit/delete)
- Git operations: commit, branch, merge
- Mail: sent, received, read
- Errors: stack traces with agent context

**Secret redaction** (from kotadb pattern):
```typescript
const REDACT_PATTERNS = [
  /sk-ant-[a-zA-Z0-9_-]+/g,
  /github_pat_[a-zA-Z0-9_]+/g,
  /Bearer\s+[a-zA-Z0-9._-]+/g,
  /ghp_[a-zA-Z0-9]+/g,
  /ANTHROPIC_API_KEY=[^\s]+/g,
];
```

---

## Worktree Lifecycle

### On-Demand Creation

```bash
overstory sling --task bd-abc --capability builder --name auth-login
```

This command:
1. Creates worktree at `.overstory/worktrees/auth-login/`
2. Creates branch: `overstory/auth-login/bd-abc`
3. Writes `.claude/CLAUDE.md` (dynamic overlay) into worktree
4. Writes `.claude/settings.local.json` (hooks) into worktree
5. Sets env var `OVERSTORY_AGENT_NAME=auth-login`
6. Starts tmux session: `overstory-auth-login`
7. Launches `claude` inside the tmux session

### Merge

```bash
# Merge a single branch
overstory merge --branch overstory/auth-login/bd-abc

# Merge all completed agent branches
overstory merge --all

# Dry-run to check for conflicts
overstory merge --branch overstory/auth-login/bd-abc --dry-run
```

**Resolution tiers:**
1. **Clean merge** — `git merge` succeeds, done
2. **Auto-resolve** — Standard git conflict markers resolved automatically
3. **AI resolve** — Spawn a Claude session to read both versions and merge intelligently
4. **Re-imagine** — Spawn a Claude session to reimplement the change against current main

Tiers escalate automatically. Each tier is configurable (enable/disable).

### Cleanup

```bash
# Clean specific worktree
overstory worktree clean auth-login

# Clean all completed worktrees (agents that have exited)
overstory worktree clean --completed

# List worktrees with status
overstory worktree list
```

Cleanup removes:
1. Worktree directory
2. Branch reference (if merged)
3. Tmux session (if still running, kill first)
4. Log files are preserved (never auto-deleted)

---

## Directory Structure

```
overstory/                             # The overstory tool itself
├── src/
│   ├── index.ts                       # CLI entry point (command router)
│   ├── types.ts                       # All shared types and interfaces
│   ├── config.ts                      # Config loader + defaults + validation
│   ├── errors.ts                      # Custom error types
│   │
│   ├── commands/                      # CLI command implementations
│   │   ├── init.ts                    # overstory init
│   │   ├── sling.ts                   # overstory sling (spawn worker)
│   │   ├── status.ts                 # overstory status
│   │   ├── prime.ts                   # overstory prime (context loading)
│   │   ├── mail.ts                    # overstory mail send/check/list/read
│   │   ├── merge.ts                   # overstory merge
│   │   ├── worktree.ts               # overstory worktree list/clean
│   │   ├── log.ts                     # overstory log (hook logger)
│   │   ├── watch.ts                   # overstory watch (watchdog)
│   │   └── metrics.ts                 # overstory metrics
│   │
│   ├── agents/
│   │   ├── manifest.ts               # Agent registry (load + query capabilities)
│   │   ├── overlay.ts                # Dynamic CLAUDE.md overlay generator
│   │   ├── identity.ts               # Persistent agent identity (CVs)
│   │   └── hooks-deployer.ts         # Deploy hooks to worktree
│   │
│   ├── worktree/
│   │   ├── manager.ts                # Create / list / cleanup git worktrees
│   │   └── tmux.ts                   # Tmux session management
│   │
│   ├── beads/
│   │   ├── client.ts                 # bd CLI wrapper (--json parsing)
│   │   └── molecules.ts             # Molecule management helpers
│   │
│   ├── mail/
│   │   ├── store.ts                  # SQLite mail storage (bun:sqlite)
│   │   └── client.ts                 # Mail send/check/list/read operations
│   │
│   ├── mulch/
│   │   └── client.ts                 # mulch CLI wrapper (prime/record/status --json)
│   │
│   ├── merge/
│   │   ├── queue.ts                  # Branch merge queue (FIFO)
│   │   └── resolver.ts              # Tiered conflict resolution
│   │
│   ├── watchdog/
│   │   ├── daemon.ts                 # Tier 1: mechanical process monitoring
│   │   ├── triage.ts                 # Tier 2: AI-assisted failure classification
│   │   └── health.ts                 # Health check definitions + state machine
│   │
│   ├── logging/
│   │   ├── logger.ts                 # Multi-format logger (human + NDJSON)
│   │   ├── sanitizer.ts             # Secret redaction
│   │   └── reporter.ts              # Console reporter (ANSI colors)
│   │
│   └── metrics/
│       ├── store.ts                  # SQLite metrics storage
│       └── summary.ts               # Metrics reporting
│
├── agents/                            # Base agent definitions (the HOW)
│   ├── scout.md                      # Read-only exploration
│   ├── builder.md                    # Implementation
│   ├── reviewer.md                   # Read-only validation
│   ├── lead.md                       # Team lead (can spawn sub-workers)
│   └── merger.md                     # Branch merge specialist
│
├── templates/
│   ├── CLAUDE.md.tmpl                # Template for orchestrator's CLAUDE.md
│   ├── overlay.md.tmpl               # Template for per-worker overlay
│   └── hooks.json.tmpl              # Template for settings.local.json
│
├── __tests__/
│   ├── config.test.ts
│   ├── manifest.test.ts
│   ├── worktree.test.ts
│   ├── tmux.test.ts
│   ├── beads-client.test.ts
│   ├── mail-store.test.ts
│   ├── mail-client.test.ts
│   ├── merge-queue.test.ts
│   ├── resolver.test.ts
│   ├── overlay.test.ts
│   └── hooks-deployer.test.ts
│
├── package.json
├── tsconfig.json
├── biome.json
├── CLAUDE.md
└── README.md
```

### What gets created in a TARGET project (via `overstory init`)

```
target-project/
├── .overstory/
│   ├── config.yaml                   # Project configuration
│   ├── agent-manifest.json           # Agent registry for this project
│   ├── hooks.json                    # Central hooks config
│   ├── agents/                       # Agent state
│   │   └── {name}/
│   │       ├── identity.yaml
│   │       └── work-history.md
│   ├── worktrees/                    # Git worktrees (gitignored)
│   │   └── {agent-name}/
│   ├── specs/                        # Task specifications
│   │   └── {bead-id}.md
│   ├── logs/                         # Agent logs (gitignored)
│   │   └── {agent-name}/{timestamp}/
│   ├── mail.db                       # SQLite mail (gitignored, WAL mode)
│   └── metrics.db                    # SQLite metrics (gitignored)
├── .gitignore                        # Updated with .overstory/worktrees, logs, metrics.db
└── .claude/
    └── CLAUDE.md                     # Updated with overstory awareness
```

---

## Core Types (`src/types.ts`)

```typescript
// === Project Configuration ===

export interface OverstoryConfig {
  project: {
    name: string;
    root: string;                          // Absolute path to target repo
    canonicalBranch: string;               // "main" | "develop"
  };
  agents: {
    manifestPath: string;                  // Path to agent-manifest.json
    baseDir: string;                       // Path to base agent definitions
    maxConcurrent: number;                 // Rate limit ceiling
    staggerDelayMs: number;               // Delay between spawns
    maxDepth: number;                      // Hierarchy depth limit (default 2)
  };
  worktrees: {
    baseDir: string;                       // Where worktrees live
  };
  beads: {
    enabled: boolean;
  };
  mulch: {
    enabled: boolean;
    domains: string[];                     // Domains to prime (empty = auto-detect)
    primeFormat: "markdown" | "xml" | "json";
  };
  merge: {
    aiResolveEnabled: boolean;
    reimagineEnabled: boolean;
  };
  watchdog: {
    tier1Enabled: boolean;
    tier1IntervalMs: number;               // Default 30_000
    tier2Enabled: boolean;
    staleThresholdMs: number;              // When to consider agent stale
    zombieThresholdMs: number;             // When to kill
  };
  logging: {
    verbose: boolean;
    redactSecrets: boolean;
  };
}

// === Agent Manifest ===

export interface AgentManifest {
  version: string;
  agents: Record<string, AgentDefinition>;
  capabilityIndex: Record<string, string[]>;
}

export interface AgentDefinition {
  file: string;                            // Path to base agent definition (.md)
  model: "sonnet" | "opus" | "haiku";
  tools: string[];                         // Allowed tools
  capabilities: string[];                  // What this agent can do
  canSpawn: boolean;                       // Can this agent spawn sub-workers?
  constraints: string[];                   // Machine-readable restrictions
}

// === Agent Session ===

export type AgentState = "booting" | "working" | "stalled" | "zombie";

export interface AgentSession {
  id: string;                              // Unique session ID
  agentName: string;                       // Unique per-session name
  capability: string;                      // Which agent definition
  worktreePath: string;
  branchName: string;
  beadId: string;                          // Task being worked
  tmuxSession: string;                     // Tmux session name
  state: AgentState;
  pid: number | null;                      // Claude Code PID
  parentAgent: string | null;              // Who spawned this agent (null = orchestrator)
  depth: number;                           // 0 = direct from orchestrator
  startedAt: string;
  lastActivity: string;
}

// === Agent Identity ===

export interface AgentIdentity {
  name: string;
  capability: string;
  created: string;
  sessionsCompleted: number;
  expertiseDomains: string[];
  recentTasks: Array<{
    beadId: string;
    summary: string;
    completedAt: string;
  }>;
}

// === Mail (Custom SQLite) ===

export interface MailMessage {
  id: string;                              // "msg-" + nanoid(12)
  from: string;                            // Agent name
  to: string;                              // Agent name or "orchestrator"
  subject: string;
  body: string;
  priority: "low" | "normal" | "high" | "urgent";
  type: "status" | "question" | "result" | "error";
  threadId: string | null;                 // Conversation threading
  read: boolean;
  createdAt: string;                       // ISO timestamp
}

// === Overlay ===

export interface OverlayConfig {
  agentName: string;
  beadId: string;
  specPath: string | null;
  branchName: string;
  fileScope: string[];
  mulchDomains: string[];
  parentAgent: string | null;
  depth: number;
  canSpawn: boolean;
}

// === Merge Queue ===

export type ResolutionTier =
  | "clean-merge"
  | "auto-resolve"
  | "ai-resolve"
  | "reimagine";

export interface MergeEntry {
  branchName: string;
  beadId: string;
  agentName: string;
  filesModified: string[];
  enqueuedAt: string;
  status: "pending" | "merging" | "merged" | "conflict" | "failed";
  resolvedTier: ResolutionTier | null;
}

export interface MergeResult {
  entry: MergeEntry;
  success: boolean;
  tier: ResolutionTier;
  conflictFiles: string[];
  errorMessage: string | null;
}

// === Watchdog ===

export interface HealthCheck {
  agentName: string;
  timestamp: string;
  processAlive: boolean;
  tmuxAlive: boolean;
  lastActivity: string;
  state: AgentState;
  action: "none" | "escalate" | "terminate";
}

// === Logging ===

export interface LogEvent {
  timestamp: string;
  level: "debug" | "info" | "warn" | "error";
  event: string;
  agentName: string | null;
  data: Record<string, unknown>;
}

// === Metrics ===

export interface SessionMetrics {
  agentName: string;
  beadId: string;
  capability: string;
  startedAt: string;
  completedAt: string | null;
  durationMs: number;
  exitCode: number | null;
  mergeResult: ResolutionTier | null;
  parentAgent: string | null;
}
```

---

## CLI Command Reference

The `overstory` binary is the entire interface. Everything goes through it.

```
overstory init                              Initialize .overstory/ in current project
overstory sling <task-id>                   Spawn a worker agent
  --capability <type>                         Agent capability (builder, scout, reviewer, lead)
  --name <name>                               Agent name (unique per session)
  --spec <path>                               Path to spec file
  --files <file1,file2>                       Exclusive file scope
  --parent <agent-name>                       Parent agent (for hierarchy tracking)
  --depth <n>                                 Current hierarchy depth

overstory prime                             Load context for orchestrator/agent
  --agent <name>                              Agent name (for per-agent priming)
  --compact                                   Compact mode (less context)

overstory status                            Show system state
  --json                                      JSON output
  --watch                                     Live updating

overstory mail send                         Send a message (SQLite INSERT)
  --to <agent-name>                           Recipient
  --subject <text>                            Subject line
  --body <text>                               Message body
  --type <status|question|result|error>       Message type
  --priority <low|normal|high|urgent>         Priority

overstory mail check                        Check inbox
  --agent <name>                              Which agent's inbox
  --inject                                    Output for hook context injection
  --json                                      JSON output

overstory mail list                         List all messages
  --from <name>                               Filter by sender
  --to <name>                                 Filter by recipient
  --unread                                    Unread only

overstory mail read <id>                    Mark message as read
overstory mail reply <id>                   Reply in same thread
  --body <text>                               Reply body

overstory merge                             Merge agent branches
  --branch <name>                             Specific branch
  --all                                       All completed branches
  --dry-run                                   Check conflicts without merging

overstory worktree list                     List worktrees with status
overstory worktree clean                    Clean completed worktrees
  --completed                                 Only completed agents
  --all                                       All worktrees (force)

overstory log <event>                       Log an event (called by hooks)
  --agent <name>                              Agent name
  tool-start, tool-end, session-end           Event types

overstory watch                             Start watchdog daemon
  --interval <ms>                             Check interval
  --background                                Run as daemon

overstory metrics                           Show metrics summary
  --last <n>                                  Last N sessions
  --json                                      JSON output
```

---

## Implementation Layers

### Layer 0: Project Scaffolding

**Dependency:** None

| Task | Files | Description |
|------|-------|-------------|
| L0-1 | `package.json`, `tsconfig.json`, `biome.json` | Bun init, strict TS, Biome config |
| L0-2 | `src/types.ts`, `src/errors.ts` | All interfaces from types section |
| L0-3 | `src/config.ts` | YAML config loader with defaults + validation |
| L0-4 | `CLAUDE.md` | Overstory project conventions |
| L0-5 | `agents/*.md` | Base agent definitions (scout, builder, reviewer, lead, merger) |
| L0-6 | `templates/*.tmpl` | CLAUDE.md overlay template, hooks template |

**L0-1: package.json**
```json
{
  "name": "overstory",
  "version": "0.1.0",
  "type": "module",
  "bin": { "overstory": "./src/index.ts" },
  "dependencies": {},
  "devDependencies": {
    "@types/bun": "latest",
    "typescript": "^5.9.0",
    "@biomejs/biome": "^1.9.0"
  }
}
```

Zero runtime dependencies. `bd` and `mulch` are CLI tools, not npm packages.
Bun runs TypeScript directly — no build step.

**L0-1: tsconfig.json**
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noFallthroughCasesInSwitch": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "isolatedModules": true,
    "skipLibCheck": true,
    "paths": { "@/*": ["./src/*"] }
  },
  "include": ["src/**/*.ts", "__tests__/**/*.ts"]
}
```

**L0-1: biome.json**
```json
{
  "$schema": "https://biomejs.dev/schemas/1.9.0/schema.json",
  "organizeImports": { "enabled": true },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "correctness": { "noUnusedVariables": "error", "noUnusedImports": "error" },
      "suspicious": { "noExplicitAny": "error" },
      "style": { "noNonNullAssertion": "warn", "useConst": "error" }
    }
  },
  "formatter": { "enabled": true, "indentStyle": "tab", "lineWidth": 100 }
}
```

---

### Layer 1: Core Infrastructure (All Parallel)

**Dependency:** Layer 0

| Task | Files | Description |
|------|-------|-------------|
| L1-1 | `src/logging/*` | Logger, sanitizer, ANSI reporter |
| L1-2 | `src/agents/manifest.ts` | Load manifest, capability routing, validation |
| L1-3 | `src/worktree/manager.ts` | Create/list/cleanup worktrees via git CLI |
| L1-4 | `src/worktree/tmux.ts` | Create/list/kill/attach tmux sessions |
| L1-5 | `src/beads/client.ts` | Wrap `bd` CLI, parse `--json` output |
| L1-6 | `src/mulch/client.ts` | Wrap `mulch` CLI, prime with `--json` output |
| L1-7 | `src/metrics/store.ts`, `src/metrics/summary.ts` | SQLite via bun:sqlite |
| L1-8 | `src/mail/store.ts` | SQLite mail storage (schema, CRUD, WAL mode) |

**L1-3: Worktree Manager**
```typescript
export async function createWorktree(options: {
  repoRoot: string;
  baseDir: string;
  agentName: string;
  baseBranch: string;
  beadId: string;
}): Promise<{ path: string; branch: string }>;

export async function listWorktrees(baseDir: string): Promise<Array<{
  path: string;
  branch: string;
  agentName: string;
}>>;

export async function removeWorktree(path: string): Promise<void>;
```

All via `Bun.spawn(["git", "worktree", ...])`. Branch naming: `overstory/{agentName}/{beadId}`.

**L1-4: Tmux Manager**
```typescript
export async function createSession(name: string, cwd: string, command: string): Promise<number>;
export async function listSessions(): Promise<Array<{ name: string; pid: number }>>;
export async function killSession(name: string): Promise<void>;
export async function isSessionAlive(name: string): Promise<boolean>;
export async function sendKeys(name: string, keys: string): Promise<void>;
```

All via `Bun.spawn(["tmux", ...])`. Session naming: `overstory-{agentName}`.

**L1-5: Beads Client**
```typescript
export interface BeadsClient {
  ready(options?: { mol?: string }): Promise<BeadIssue[]>;
  show(id: string): Promise<BeadIssue>;
  create(title: string, options?: CreateOptions): Promise<BeadIssue>;
  claim(id: string): Promise<void>;
  close(id: string, reason?: string): Promise<void>;
  status(): Promise<BeadsStatus>;
  molPour(protoId: string, vars?: Record<string, string>): Promise<string>;
}

export function createBeadsClient(cwd: string): BeadsClient;
```

---

### Layer 2: Agent Lifecycle + Mail (Depends on Layer 1)

**Dependency:** L1-1 through L1-6

| Task | Files | Description |
|------|-------|-------------|
| L2-1 | `src/agents/overlay.ts` | Generate per-worker CLAUDE.md overlay |
| L2-2 | `src/agents/hooks-deployer.ts` | Deploy hooks config to worktree |
| L2-3 | `src/agents/identity.ts` | Create/load/update agent identity |
| L2-4 | `src/mail/client.ts` | Mail client (send/check/list/read/reply over SQLite store) |
| L2-5 | `src/commands/sling.ts` | The `overstory sling` command (creates worktree + overlay + hooks + tmux) |
| L2-6 | `src/commands/prime.ts` | The `overstory prime` command (context loading) |
| L2-7 | `src/commands/mail.ts` | The `overstory mail` CLI command family |

**L2-1: Overlay Generator**
```typescript
export function generateOverlay(config: OverlayConfig): string;
export function writeOverlay(worktreePath: string, config: OverlayConfig): Promise<void>;
```

Reads `templates/overlay.md.tmpl`, fills in variables, writes to `{worktree}/.claude/CLAUDE.md`.

**L2-4: Mail Client (over SQLite)**
```typescript
export interface MailClient {
  send(message: Omit<MailMessage, "id" | "createdAt" | "read">): string;  // Sync, returns ID
  check(agentName: string): MailMessage[];             // Unread messages for agent
  checkInject(agentName: string): string;              // Formatted for hook injection
  list(filters?: { from?: string; to?: string; unread?: boolean }): MailMessage[];
  markRead(messageId: string): void;
  reply(messageId: string, body: string): string;      // Creates reply in same thread
}

export function createMailClient(dbPath: string): MailClient;
```

Implementation: All operations are synchronous SQLite queries via `bun:sqlite`. The mail store (L1-8) handles schema creation, WAL mode, and prepared statements. The client wraps store operations with ID generation and thread management.

Note: Synchronous by design — `bun:sqlite` is sync and ~1-5ms per query. No need for async overhead on local DB operations.

**L2-5: Sling Command (Critical Path)**

This is the most important command. Orchestrates the full spawn sequence:

```typescript
export async function sling(options: {
  beadId: string;
  capability: string;
  agentName: string;
  specPath?: string;
  fileScope?: string[];
  parentAgent?: string;
  depth?: number;
}): Promise<AgentSession>;
```

Steps:
1. Load config + manifest
2. Validate: agent name unique, depth within limit, beadId exists
3. Create worktree (git worktree add)
4. Generate overlay CLAUDE.md → write to worktree
5. Generate hooks config → write to worktree as `.claude/settings.local.json`
6. Claim beads issue (`bd update --claim`)
7. Create tmux session running `claude` in the worktree
8. Record session in `.overstory/sessions.json`
9. Return session info

---

### Layer 3: Merge + Orchestration (Depends on Layer 2)

**Dependency:** L2-5 (sling), L1-5 (beads)

| Task | Files | Description |
|------|-------|-------------|
| L3-1 | `src/merge/queue.ts` | FIFO merge queue |
| L3-2 | `src/merge/resolver.ts` | Tiered conflict resolution (all 4 tiers) |
| L3-3 | `src/beads/molecules.ts` | Molecule helpers for multi-step workflows |
| L3-4 | `src/commands/merge.ts` | The `overstory merge` command |
| L3-5 | `src/commands/status.ts` | The `overstory status` command |
| L3-6 | `src/commands/worktree.ts` | The `overstory worktree` command |

**L3-2: Tiered Resolver**
```typescript
export async function resolve(options: {
  repoRoot: string;
  branch: string;
  targetBranch: string;
  aiEnabled: boolean;
  reimagineEnabled: boolean;
}): Promise<MergeResult>;
```

Tier escalation:
1. `git merge --no-edit` → if exit 0, done (clean-merge)
2. Parse conflict markers, attempt auto-resolve → if success, commit (auto-resolve)
3. Spawn `claude --print` with both file versions, ask to merge → apply result (ai-resolve)
4. Spawn `claude --print` on fresh checkout of target, ask to reimplement → apply result (reimagine)

---

### Layer 4: Watchdog + CLI Router (Depends on Layer 3)

**Dependency:** L3-5 (status), L2-5 (sling), L1-4 (tmux)

| Task | Files | Description |
|------|-------|-------------|
| L4-1 | `src/watchdog/daemon.ts` | Tier 1: mechanical process monitoring |
| L4-2 | `src/watchdog/triage.ts` | Tier 2: AI-assisted failure classification |
| L4-3 | `src/watchdog/health.ts` | Health check definitions + state transitions |
| L4-4 | `src/commands/watch.ts` | The `overstory watch` command |
| L4-5 | `src/commands/log.ts` | The `overstory log` command (hook target) |
| L4-6 | `src/commands/metrics.ts` | The `overstory metrics` command |
| L4-7 | `src/commands/init.ts` | The `overstory init` command |
| L4-8 | `src/index.ts` | CLI router (all commands) |

**L4-1: Tier 1 Daemon**

Runs on interval (default 30s). For each active session:
1. Check tmux session alive (`tmux has-session`)
2. Check Claude process alive (`kill -0 pid`)
3. Check last activity timestamp
4. Transition state: working → stalled → zombie → terminate

```typescript
export function startDaemon(options: {
  configPath: string;
  intervalMs: number;
  onStateChange: (agent: string, from: AgentState, to: AgentState) => void;
}): { stop: () => void };
```

---

### Layer 5: Tests (Parallel with Layers 3-4)

| Task | Files | Description |
|------|-------|-------------|
| L5-1 | `__tests__/config.test.ts` | Config loading, defaults, validation |
| L5-2 | `__tests__/manifest.test.ts` | Manifest loading, capability routing |
| L5-3 | `__tests__/worktree.test.ts` | Worktree create/list/remove (temp dirs) |
| L5-4 | `__tests__/tmux.test.ts` | Tmux session management |
| L5-5 | `__tests__/beads-client.test.ts` | Beads CLI wrapper (mock subprocess) |
| L5-6 | `__tests__/mail-store.test.ts` | SQLite mail schema, CRUD, WAL concurrency |
| L5-7 | `__tests__/mail-client.test.ts` | Send/check/list/read/reply, thread management |
| L5-8 | `__tests__/merge-queue.test.ts` | Queue ordering, conflict detection |
| L5-9 | `__tests__/resolver.test.ts` | All 4 resolution tiers |
| L5-10 | `__tests__/overlay.test.ts` | Overlay generation, template rendering |
| L5-11 | `__tests__/hooks-deployer.test.ts` | Hooks config deployment |

---

## Implementation Order (Critical Path)

```
Layer 0: Scaffolding (6 tasks)
  │  package.json, tsconfig, biome, types, config, agent defs, templates
  │
  ├──→ Layer 1: Core Infrastructure (8 tasks, ALL PARALLEL)
  │      logger, manifest, worktree-mgr, tmux, beads-client, mulch-client, metrics, mail-store
  │      │
  │      ├──→ Layer 2: Agent Lifecycle + Mail (7 tasks, ALL PARALLEL)
  │      │      overlay, hooks-deployer, identity, mail-client, sling, prime, mail-cmd
  │      │      │
  │      │      ├──→ Layer 3: Merge + Orchestration (6 tasks, ALL PARALLEL)
  │      │      │      merge-queue, resolver, molecules, merge-cmd, status-cmd, worktree-cmd
  │      │      │      │
  │      │      │      └──→ Layer 4: Watchdog + CLI (8 tasks, ALL PARALLEL)
  │      │      │             daemon, triage, health, watch-cmd, log-cmd, metrics-cmd, init-cmd, router
  │      │      │
  │      └──→ Layer 5: Tests (10 tasks, ALL PARALLEL with Layers 3-4)
  │
  Total: 45 tasks across 6 layers
```

---

## File Ownership Map (For Team Building)

| Teammate | Exclusive Files |
|----------|----------------|
| **scaffolder** | `package.json`, `tsconfig.json`, `biome.json`, `CLAUDE.md` |
| **types-author** | `src/types.ts`, `src/errors.ts`, `src/config.ts` |
| **agent-defs** | `agents/*.md`, `templates/*.tmpl` |
| **logger** | `src/logging/*` |
| **manifest** | `src/agents/manifest.ts` |
| **worktree** | `src/worktree/manager.ts` |
| **tmux** | `src/worktree/tmux.ts` |
| **beads** | `src/beads/client.ts` |
| **mulch** | `src/mulch/client.ts` |
| **metrics** | `src/metrics/*` |
| **overlay** | `src/agents/overlay.ts` |
| **hooks** | `src/agents/hooks-deployer.ts` |
| **identity** | `src/agents/identity.ts` |
| **mail** | `src/mail/*`, `src/commands/mail.ts` |
| **sling** | `src/commands/sling.ts`, `src/commands/prime.ts` |
| **merger** | `src/merge/*`, `src/commands/merge.ts` |
| **molecules** | `src/beads/molecules.ts` |
| **watchdog** | `src/watchdog/*`, `src/commands/watch.ts` |
| **cli** | `src/index.ts`, `src/commands/init.ts`, `src/commands/status.ts`, `src/commands/worktree.ts`, `src/commands/log.ts`, `src/commands/metrics.ts` |
| **tests** | `__tests__/*` |

---

## Resolved Questions

| Question | Answer |
|----------|--------|
| How does the orchestrator get tasks? | Human tells Claude Code what to build. Claude Code calls `bd create` or uses existing beads issues. |
| How does the orchestrator inject task context? | Library base `.md` (HOW) + dynamic overlay CLAUDE.md (WHAT). Written to worktree before spawn. |
| Should reimagine use a fresh worktree? | Yes. Fresh checkout of target branch, reimplement from scratch. |
| Rate limit discovery? | Start with `maxConcurrent` from config. Exponential backoff on spawn failures. |
| Agent prompt injection method? | Template rendering. `templates/overlay.md.tmpl` with `{{BEAD_ID}}`, `{{FILE_SCOPE}}`, etc. |

---

## Validation Criteria

The system is done when:

- [ ] `overstory init` scaffolds `.overstory/` in any git repo
- [ ] `overstory sling` creates worktree + overlay + hooks + tmux session
- [ ] Worker agents execute tasks and close beads issues on completion
- [ ] `overstory mail send/check` enables agent-to-agent communication
- [ ] `overstory merge` integrates branches with tiered conflict resolution
- [ ] `overstory status` shows all active agents, worktrees, beads state
- [ ] `overstory watch` detects and terminates zombie agents
- [ ] Hierarchical delegation works (lead spawns sub-workers via `overstory sling`)
- [ ] Hooks capture all tool use, file edits, and session lifecycle events
- [ ] Logs in multi-format (human + NDJSON) with secret redaction
- [ ] All of the above works against any git repo (project-agnostic)
- [ ] `bun test` passes
- [ ] `biome check` passes with zero errors
